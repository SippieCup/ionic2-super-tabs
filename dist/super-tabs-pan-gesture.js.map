{"version":3,"file":"super-tabs-pan-gesture.js","sourceRoot":"","sources":["../src/super-tabs-pan-gesture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from 'ionic-angular';\nimport { pointerCoord, PointerCoordinates } from 'ionic-angular/util/dom';\nimport { SuperTabsConfig } from './components/super-tabs';\nimport { Renderer2 } from '@angular/core';\n\nexport class SuperTabsPanGesture {\n\n  onMove: (delta: number) => void;\n\n  onEnd: (shortSwipe: boolean, shortSwipeDelta?: number) => void;\n\n  private initialCoords: PointerCoordinates;\n\n  private initialTimestamp: number;\n\n  private leftThreshold: number = 0;\n\n  private rightThreshold: number = 0;\n\n  private shouldCapture: boolean;\n\n  private isDragging: boolean;\n\n  private lastPosX: number;\n\n  private listeners: Function[] = [];\n\n  constructor(\n    private plt: Platform,\n    private el: HTMLElement,\n    private config: SuperTabsConfig,\n    private rnd: Renderer2\n  ) {\n\n    this.listeners.push(\n      rnd.listen(el, 'touchstart', this._onStart.bind(this)),\n      rnd.listen(el, 'touchmove', this._onMove.bind(this)),\n      rnd.listen(el, 'touchend', this._onEnd.bind(this))\n    );\n\n    if (config.sideMenu === 'both' || config.sideMenu === 'left') {\n      this.leftThreshold = config.sideMenuThreshold;\n    }\n\n    if (config.sideMenu === 'both' || config.sideMenu === 'right') {\n      this.rightThreshold = config.sideMenuThreshold;\n    }\n\n  }\n\n  destroy() {\n    this.listeners.forEach(fn => fn());\n  }\n\n  private _onStart(ev: TouchEvent) {\n    const coords: PointerCoordinates = pointerCoord(ev),\n      vw = this.plt.width();\n\n    if (coords.x < this.leftThreshold || coords.x > vw - this.rightThreshold) {\n      // ignore this gesture, it started in the side menu touch zone\n      this.shouldCapture = false;\n      return;\n    }\n\n    // the starting point looks good, let's see what happens when we move\n\n    this.initialCoords = coords;\n    if (this.config.shortSwipeDuration > 0) this.initialTimestamp = Date.now();\n    this.lastPosX = coords.x;\n\n  }\n\n  private _onMove(ev: TouchEvent) {\n\n    const coords: PointerCoordinates = pointerCoord(ev);\n\n    if (!this.isDragging) {\n\n      if (typeof this.shouldCapture !== 'boolean')\n      // we haven't decided yet if we want to capture this gesture\n        this.checkGesture(coords);\n\n\n      if (this.shouldCapture === true)\n      // gesture is good, let's capture all next onTouchMove events\n        this.isDragging = true;\n      else\n        return;\n\n    }\n\n    // stop anything else from capturing these events, to make sure the content doesn't slide\n    ev.stopPropagation();\n    ev.preventDefault();\n\n    // get delta X\n    const deltaX: number = this.lastPosX - coords.x;\n\n    // emit value\n    this.onMove && this.onMove(deltaX);\n\n    // update last X value\n    this.lastPosX = coords.x;\n\n  }\n\n  private _onEnd(ev: TouchEvent) {\n    const coords: PointerCoordinates = pointerCoord(ev);\n\n    if (this.shouldCapture === true) {\n\n      if (this.config.shortSwipeDuration > 0) {\n\n        const deltaTime: number = Date.now() - this.initialTimestamp;\n\n        if (deltaTime <= this.config.shortSwipeDuration)\n          this.onEnd && this.onEnd(true, coords.x - this.initialCoords.x);\n        else this.onEnd && this.onEnd(false);\n\n      } else this.onEnd && this.onEnd(false);\n\n    }\n\n    this.isDragging = false;\n    this.shouldCapture = undefined;\n\n  }\n\n  private checkGesture(newCoords: PointerCoordinates) {\n\n    const radians = this.config.maxDragAngle * (Math.PI / 180),\n      maxCosine = Math.cos(radians),\n      deltaX = newCoords.x - this.initialCoords.x,\n      deltaY = newCoords.y - this.initialCoords.y,\n      distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n    if (distance >= this.config.dragThreshold) {\n      // swipe is long enough so far\n      // lets check the angle\n      const angle = Math.atan2(deltaY, deltaX),\n        cosine = Math.cos(angle);\n\n      this.shouldCapture = Math.abs(cosine) > maxCosine;\n    }\n\n  }\n\n}\n"]}